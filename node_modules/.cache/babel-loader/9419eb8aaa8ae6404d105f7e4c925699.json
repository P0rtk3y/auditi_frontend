{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nimport AudioContext from './AudioContext';\nvar analyser = void 0;\nvar audioCtx = void 0;\nvar mediaRecorder = void 0;\nvar chunks = [];\nvar startTime = void 0;\nvar stream = void 0;\nvar mediaOptions = void 0;\nvar blobObject = void 0;\nvar onStartCallback = void 0;\nvar onStopCallback = void 0;\nvar onSaveCallback = void 0;\nvar onDataCallback = void 0;\nvar constraints = {\n  audio: true,\n  video: false\n}; // constraints - only audio needed\n\nnavigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;\nexport var MicrophoneRecorder = function () {\n  function MicrophoneRecorder(onStart, onStop, onSave, onData, options) {\n    var _this = this;\n\n    _classCallCheck(this, MicrophoneRecorder);\n\n    this.startRecording = function () {\n      startTime = Date.now();\n\n      if (mediaRecorder) {\n        if (audioCtx && audioCtx.state === 'suspended') {\n          audioCtx.resume();\n        }\n\n        if (mediaRecorder && mediaRecorder.state === 'paused') {\n          mediaRecorder.resume();\n          return;\n        }\n\n        if (audioCtx && mediaRecorder && mediaRecorder.state === 'inactive') {\n          mediaRecorder.start(10);\n          var source = audioCtx.createMediaStreamSource(stream);\n          source.connect(analyser);\n\n          if (onStartCallback) {\n            onStartCallback();\n          }\n\n          ;\n        }\n      } else {\n        if (navigator.mediaDevices) {\n          console.log('getUserMedia supported.');\n          navigator.mediaDevices.getUserMedia(constraints).then(function (str) {\n            stream = str;\n\n            if (MediaRecorder.isTypeSupported(mediaOptions.mimeType)) {\n              mediaRecorder = new MediaRecorder(str, mediaOptions);\n            } else {\n              mediaRecorder = new MediaRecorder(str);\n            }\n\n            if (onStartCallback) {\n              onStartCallback();\n            }\n\n            ;\n            mediaRecorder.onstop = _this.onStop;\n\n            mediaRecorder.ondataavailable = function (event) {\n              chunks.push(event.data);\n\n              if (onDataCallback) {\n                onDataCallback(event.data);\n              }\n            };\n\n            audioCtx = AudioContext.getAudioContext();\n            audioCtx.resume().then(function () {\n              analyser = AudioContext.getAnalyser();\n              mediaRecorder.start(10);\n              var sourceNode = audioCtx.createMediaStreamSource(stream);\n              sourceNode.connect(analyser);\n            });\n          });\n        } else {\n          alert('Your browser does not support audio recording');\n        }\n      }\n    };\n\n    onStartCallback = onStart;\n    onStopCallback = onStop;\n    onSaveCallback = onSave;\n    onDataCallback = onData;\n    mediaOptions = options;\n  }\n\n  MicrophoneRecorder.prototype.stopRecording = function stopRecording() {\n    if (mediaRecorder && mediaRecorder.state !== 'inactive') {\n      mediaRecorder.stop();\n      stream.getAudioTracks().forEach(function (track) {\n        track.stop();\n      });\n      mediaRecorder = null;\n      AudioContext.resetAnalyser();\n    }\n  };\n\n  MicrophoneRecorder.prototype.onStop = function onStop(evt) {\n    var blob = new Blob(chunks, {\n      'type': mediaOptions.mimeType\n    });\n    chunks = [];\n    var blobObject = {\n      blob: blob,\n      startTime: startTime,\n      stopTime: Date.now(),\n      options: mediaOptions,\n      blobURL: window.URL.createObjectURL(blob)\n    };\n\n    if (onStopCallback) {\n      onStopCallback(blobObject);\n    }\n\n    ;\n\n    if (onSaveCallback) {\n      onSaveCallback(blobObject);\n    }\n\n    ;\n  };\n\n  return MicrophoneRecorder;\n}();","map":{"version":3,"sources":["/Users/skout/Desktop/Auditi/auditi_frontend/node_modules/react-mic/es/libs/MicrophoneRecorder.js"],"names":["_classCallCheck","instance","Constructor","TypeError","AudioContext","analyser","audioCtx","mediaRecorder","chunks","startTime","stream","mediaOptions","blobObject","onStartCallback","onStopCallback","onSaveCallback","onDataCallback","constraints","audio","video","navigator","getUserMedia","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","MicrophoneRecorder","onStart","onStop","onSave","onData","options","_this","startRecording","Date","now","state","resume","start","source","createMediaStreamSource","connect","mediaDevices","console","log","then","str","MediaRecorder","isTypeSupported","mimeType","onstop","ondataavailable","event","push","data","getAudioContext","getAnalyser","sourceNode","alert","prototype","stopRecording","stop","getAudioTracks","forEach","track","resetAnalyser","evt","blob","Blob","stopTime","blobURL","window","URL","createObjectURL"],"mappings":"AAAA,SAASA,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;AAAE,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;;AAEzJ,OAAOC,YAAP,MAAyB,gBAAzB;AAEA,IAAIC,QAAQ,GAAG,KAAK,CAApB;AACA,IAAIC,QAAQ,GAAG,KAAK,CAApB;AACA,IAAIC,aAAa,GAAG,KAAK,CAAzB;AACA,IAAIC,MAAM,GAAG,EAAb;AACA,IAAIC,SAAS,GAAG,KAAK,CAArB;AACA,IAAIC,MAAM,GAAG,KAAK,CAAlB;AACA,IAAIC,YAAY,GAAG,KAAK,CAAxB;AACA,IAAIC,UAAU,GAAG,KAAK,CAAtB;AACA,IAAIC,eAAe,GAAG,KAAK,CAA3B;AACA,IAAIC,cAAc,GAAG,KAAK,CAA1B;AACA,IAAIC,cAAc,GAAG,KAAK,CAA1B;AACA,IAAIC,cAAc,GAAG,KAAK,CAA1B;AAEA,IAAIC,WAAW,GAAG;AAAEC,EAAAA,KAAK,EAAE,IAAT;AAAeC,EAAAA,KAAK,EAAE;AAAtB,CAAlB,C,CAAiD;;AAEjDC,SAAS,CAACC,YAAV,GAAyBD,SAAS,CAACC,YAAV,IAA0BD,SAAS,CAACE,kBAApC,IAA0DF,SAAS,CAACG,eAApE,IAAuFH,SAAS,CAACI,cAA1H;AAEA,OAAO,IAAIC,kBAAkB,GAAG,YAAY;AAC1C,WAASA,kBAAT,CAA4BC,OAA5B,EAAqCC,MAArC,EAA6CC,MAA7C,EAAqDC,MAArD,EAA6DC,OAA7D,EAAsE;AACpE,QAAIC,KAAK,GAAG,IAAZ;;AAEA/B,IAAAA,eAAe,CAAC,IAAD,EAAOyB,kBAAP,CAAf;;AAEA,SAAKO,cAAL,GAAsB,YAAY;AAEhCvB,MAAAA,SAAS,GAAGwB,IAAI,CAACC,GAAL,EAAZ;;AAEA,UAAI3B,aAAJ,EAAmB;AAEjB,YAAID,QAAQ,IAAIA,QAAQ,CAAC6B,KAAT,KAAmB,WAAnC,EAAgD;AAC9C7B,UAAAA,QAAQ,CAAC8B,MAAT;AACD;;AAED,YAAI7B,aAAa,IAAIA,aAAa,CAAC4B,KAAd,KAAwB,QAA7C,EAAuD;AACrD5B,UAAAA,aAAa,CAAC6B,MAAd;AACA;AACD;;AAED,YAAI9B,QAAQ,IAAIC,aAAZ,IAA6BA,aAAa,CAAC4B,KAAd,KAAwB,UAAzD,EAAqE;AACnE5B,UAAAA,aAAa,CAAC8B,KAAd,CAAoB,EAApB;AACA,cAAIC,MAAM,GAAGhC,QAAQ,CAACiC,uBAAT,CAAiC7B,MAAjC,CAAb;AACA4B,UAAAA,MAAM,CAACE,OAAP,CAAenC,QAAf;;AACA,cAAIQ,eAAJ,EAAqB;AACnBA,YAAAA,eAAe;AAChB;;AAAA;AACF;AACF,OAnBD,MAmBO;AACL,YAAIO,SAAS,CAACqB,YAAd,EAA4B;AAC1BC,UAAAA,OAAO,CAACC,GAAR,CAAY,yBAAZ;AAEAvB,UAAAA,SAAS,CAACqB,YAAV,CAAuBpB,YAAvB,CAAoCJ,WAApC,EAAiD2B,IAAjD,CAAsD,UAAUC,GAAV,EAAe;AACnEnC,YAAAA,MAAM,GAAGmC,GAAT;;AAEA,gBAAIC,aAAa,CAACC,eAAd,CAA8BpC,YAAY,CAACqC,QAA3C,CAAJ,EAA0D;AACxDzC,cAAAA,aAAa,GAAG,IAAIuC,aAAJ,CAAkBD,GAAlB,EAAuBlC,YAAvB,CAAhB;AACD,aAFD,MAEO;AACLJ,cAAAA,aAAa,GAAG,IAAIuC,aAAJ,CAAkBD,GAAlB,CAAhB;AACD;;AAED,gBAAIhC,eAAJ,EAAqB;AACnBA,cAAAA,eAAe;AAChB;;AAAA;AAEDN,YAAAA,aAAa,CAAC0C,MAAd,GAAuBlB,KAAK,CAACJ,MAA7B;;AACApB,YAAAA,aAAa,CAAC2C,eAAd,GAAgC,UAAUC,KAAV,EAAiB;AAC/C3C,cAAAA,MAAM,CAAC4C,IAAP,CAAYD,KAAK,CAACE,IAAlB;;AACA,kBAAIrC,cAAJ,EAAoB;AAClBA,gBAAAA,cAAc,CAACmC,KAAK,CAACE,IAAP,CAAd;AACD;AACF,aALD;;AAOA/C,YAAAA,QAAQ,GAAGF,YAAY,CAACkD,eAAb,EAAX;AACAhD,YAAAA,QAAQ,CAAC8B,MAAT,GAAkBQ,IAAlB,CAAuB,YAAY;AAEjCvC,cAAAA,QAAQ,GAAGD,YAAY,CAACmD,WAAb,EAAX;AACAhD,cAAAA,aAAa,CAAC8B,KAAd,CAAoB,EAApB;AACA,kBAAImB,UAAU,GAAGlD,QAAQ,CAACiC,uBAAT,CAAiC7B,MAAjC,CAAjB;AACA8C,cAAAA,UAAU,CAAChB,OAAX,CAAmBnC,QAAnB;AACD,aAND;AAOD,WA7BD;AA8BD,SAjCD,MAiCO;AACLoD,UAAAA,KAAK,CAAC,+CAAD,CAAL;AACD;AACF;AACF,KA7DD;;AA+DA5C,IAAAA,eAAe,GAAGa,OAAlB;AACAZ,IAAAA,cAAc,GAAGa,MAAjB;AACAZ,IAAAA,cAAc,GAAGa,MAAjB;AACAZ,IAAAA,cAAc,GAAGa,MAAjB;AACAlB,IAAAA,YAAY,GAAGmB,OAAf;AACD;;AAEDL,EAAAA,kBAAkB,CAACiC,SAAnB,CAA6BC,aAA7B,GAA6C,SAASA,aAAT,GAAyB;AACpE,QAAIpD,aAAa,IAAIA,aAAa,CAAC4B,KAAd,KAAwB,UAA7C,EAAyD;AACvD5B,MAAAA,aAAa,CAACqD,IAAd;AAEAlD,MAAAA,MAAM,CAACmD,cAAP,GAAwBC,OAAxB,CAAgC,UAAUC,KAAV,EAAiB;AAC/CA,QAAAA,KAAK,CAACH,IAAN;AACD,OAFD;AAGArD,MAAAA,aAAa,GAAG,IAAhB;AACAH,MAAAA,YAAY,CAAC4D,aAAb;AACD;AACF,GAVD;;AAYAvC,EAAAA,kBAAkB,CAACiC,SAAnB,CAA6B/B,MAA7B,GAAsC,SAASA,MAAT,CAAgBsC,GAAhB,EAAqB;AACzD,QAAIC,IAAI,GAAG,IAAIC,IAAJ,CAAS3D,MAAT,EAAiB;AAAE,cAAQG,YAAY,CAACqC;AAAvB,KAAjB,CAAX;AACAxC,IAAAA,MAAM,GAAG,EAAT;AAEA,QAAII,UAAU,GAAG;AACfsD,MAAAA,IAAI,EAAEA,IADS;AAEfzD,MAAAA,SAAS,EAAEA,SAFI;AAGf2D,MAAAA,QAAQ,EAAEnC,IAAI,CAACC,GAAL,EAHK;AAIfJ,MAAAA,OAAO,EAAEnB,YAJM;AAKf0D,MAAAA,OAAO,EAAEC,MAAM,CAACC,GAAP,CAAWC,eAAX,CAA2BN,IAA3B;AALM,KAAjB;;AAQA,QAAIpD,cAAJ,EAAoB;AAClBA,MAAAA,cAAc,CAACF,UAAD,CAAd;AACD;;AAAA;;AACD,QAAIG,cAAJ,EAAoB;AAClBA,MAAAA,cAAc,CAACH,UAAD,CAAd;AACD;;AAAA;AACF,GAlBD;;AAoBA,SAAOa,kBAAP;AACD,CA7G+B,EAAzB","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nimport AudioContext from './AudioContext';\n\nvar analyser = void 0;\nvar audioCtx = void 0;\nvar mediaRecorder = void 0;\nvar chunks = [];\nvar startTime = void 0;\nvar stream = void 0;\nvar mediaOptions = void 0;\nvar blobObject = void 0;\nvar onStartCallback = void 0;\nvar onStopCallback = void 0;\nvar onSaveCallback = void 0;\nvar onDataCallback = void 0;\n\nvar constraints = { audio: true, video: false }; // constraints - only audio needed\n\nnavigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;\n\nexport var MicrophoneRecorder = function () {\n  function MicrophoneRecorder(onStart, onStop, onSave, onData, options) {\n    var _this = this;\n\n    _classCallCheck(this, MicrophoneRecorder);\n\n    this.startRecording = function () {\n\n      startTime = Date.now();\n\n      if (mediaRecorder) {\n\n        if (audioCtx && audioCtx.state === 'suspended') {\n          audioCtx.resume();\n        }\n\n        if (mediaRecorder && mediaRecorder.state === 'paused') {\n          mediaRecorder.resume();\n          return;\n        }\n\n        if (audioCtx && mediaRecorder && mediaRecorder.state === 'inactive') {\n          mediaRecorder.start(10);\n          var source = audioCtx.createMediaStreamSource(stream);\n          source.connect(analyser);\n          if (onStartCallback) {\n            onStartCallback();\n          };\n        }\n      } else {\n        if (navigator.mediaDevices) {\n          console.log('getUserMedia supported.');\n\n          navigator.mediaDevices.getUserMedia(constraints).then(function (str) {\n            stream = str;\n\n            if (MediaRecorder.isTypeSupported(mediaOptions.mimeType)) {\n              mediaRecorder = new MediaRecorder(str, mediaOptions);\n            } else {\n              mediaRecorder = new MediaRecorder(str);\n            }\n\n            if (onStartCallback) {\n              onStartCallback();\n            };\n\n            mediaRecorder.onstop = _this.onStop;\n            mediaRecorder.ondataavailable = function (event) {\n              chunks.push(event.data);\n              if (onDataCallback) {\n                onDataCallback(event.data);\n              }\n            };\n\n            audioCtx = AudioContext.getAudioContext();\n            audioCtx.resume().then(function () {\n\n              analyser = AudioContext.getAnalyser();\n              mediaRecorder.start(10);\n              var sourceNode = audioCtx.createMediaStreamSource(stream);\n              sourceNode.connect(analyser);\n            });\n          });\n        } else {\n          alert('Your browser does not support audio recording');\n        }\n      }\n    };\n\n    onStartCallback = onStart;\n    onStopCallback = onStop;\n    onSaveCallback = onSave;\n    onDataCallback = onData;\n    mediaOptions = options;\n  }\n\n  MicrophoneRecorder.prototype.stopRecording = function stopRecording() {\n    if (mediaRecorder && mediaRecorder.state !== 'inactive') {\n      mediaRecorder.stop();\n\n      stream.getAudioTracks().forEach(function (track) {\n        track.stop();\n      });\n      mediaRecorder = null;\n      AudioContext.resetAnalyser();\n    }\n  };\n\n  MicrophoneRecorder.prototype.onStop = function onStop(evt) {\n    var blob = new Blob(chunks, { 'type': mediaOptions.mimeType });\n    chunks = [];\n\n    var blobObject = {\n      blob: blob,\n      startTime: startTime,\n      stopTime: Date.now(),\n      options: mediaOptions,\n      blobURL: window.URL.createObjectURL(blob)\n    };\n\n    if (onStopCallback) {\n      onStopCallback(blobObject);\n    };\n    if (onSaveCallback) {\n      onSaveCallback(blobObject);\n    };\n  };\n\n  return MicrophoneRecorder;\n}();"]},"metadata":{},"sourceType":"module"}